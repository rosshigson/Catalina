/*
 * Optimize - PASM level optimizer for the Catalina compilation system.
 *
 * version 2.6 - initial release (to match Catalina version)
 *
 * verison 2.9 - found an inlining bug, where a function may be inlined if
 *               it was not a leaf function, but the function it called had
 *               been inlined.
 *
 *               Add support for '-D' and '-U' to define symbols on the
 *               command line.
 *
 * version 3.1 - found a bug if the target directory was not being used if
 *               it was set using the environment variable CATALINA_TARGET
 *
 *               found a bug where functions were not being inlined if they
 *               were leaf funtions (probably introduced as a consequence
 *               of the previous fix!)
 *
 * Version 3.4 - fix untidy mode.
 *
 * Version 3.5 - make Homespun less verbose (unless -v is specified)
 *
 * Version 3.6 - add in-place compilation support
 *
 * Version 3.10 - added optimization level 4, for removal of unused code
 *                functions and data blocks
 *
 * Version 3.11 - Added support for openspin syntax
 *                Added more verbose options - default is quiet, -v means
 *                verbose, -v -v means very verbose.
 *
 * Version 3.12 - Renamed openspin to spinnaker.
 *
 * Version 3.13 - added optimization level 5, foe load optimization
 *
 * Version 3.14 - support p2
 *
 * Version 3.15 - various minor improvements and bug fixes
 *
 * Version 3.16 - add '-k' option to suppress banner
 *
 * Version 4.0  - just update version number
 *
 * Version 4.1  - just update version number.
 *
 * Version 4.2  - just update version number.
 *
 * Version 4.3  - just update version number.
 *
 * Version 4.4  - just update version number.
 *
 * Version 4.5  - just update version number.
 *
 * Version 4.6  - just update version number.
 *
 * Version 4.9  - Fix bug in eliminating unnecesary assignments 
 *                before returning from a function.
 *
 *                Add -T command-line option to allow optimizer 
 *                to be used with different target packages when
 *                specified on the catalina command line and not 
 *                using the CATALINA_TARGET environment variable.
 *
 * Version 4.9.4 - Allow complex symbol definitions on the command line, 
 *                such as:
 *
 *                   -D "name=value".
 *
 *                This is only supported when using p2_asm as the assembler.
 *
 * Version 4.9.6 - just update version number.
 *
 * Version 5.0   - Replace single spaces in awk regular expressions with
 *                 zero or more spaces and tabs. This allows better
 *                 recognition of code that can be optimized if it is 
 *                 hand-coded and not generated by the code generator.
 *
 * Version 5.1  - just update version number.
 *
 * Version 5.2  - just update version number.
 *
 * Version 5.3  - use longer generated names to work around a bug in
 *                OpenSpin/Spinnaker.
 *
 * Version 5.4  - remove homespun.
 *
 * Version 5.5  - just update version number.
 *
 * Version 5.6  - just update version number.
 *
 * Version 5.7  - just update version number.
 *
 * Version 5.8  - just update version number.
 *
 * Version 5.9  - just update version number.
 *
 * Version 6.0  - Now supports only one file name.
 *
 * Version 6.1  - just update version number.
 *
 * Version 6.2   - just update version number.
 *
 * Version 6.3   - just update version number.
 *
 * Version 6.4   - just update version number.
 *
 * Version 6.5   - just update version number.
 *
 * Version 7.0   - just update version number.
 *
 * Version 8.3   - just update version number.
 *
 * version 8.4   - just update version number.
 *
 * version 8.5   - just update version number.
 *
 * version 8.6   - just update version number.
 *
 * version 8.7   - just update version number.
 *
 * version 8.8   - just update version number.
 *
 */

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include "catoptimize.h"

#define DO_EXECUTE         1 // 0 for debugging (output only, no execute)

#define VERSION            "8.8" 

#ifdef WIN32_PATHS         /* define this on the command line for Windows */
#define PATH_SEP           "\\"
#define DEFAULT_LCCDIR     "C:\\Program Files (x86)\\Catalina\\" // must match default used by LCC

#else
#define PATH_SEP           "/"
#define DEFAULT_LCCDIR     "/opt/catalina/" // must match default used by LCC
#endif

#define TARGET_NAME        "target"
#define DEFAULT_LCC_ENV    "LCCDIR" 
#define DEFAULT_TGT_ENV    "CATALINA_TARGET" 

#define P1_SUFFIX          "p1"
#define P2_SUFFIX          "p2"

#define MAX_FILES          1
#define MAX_LINELEN        1000
#define MAX_PATHLEN        1000
#define MAX_NAMELEN        1000
#define MAX_SYMBOLS        10000
#define MAX_DEFINES        50

#define DEFAULT_RESULT     "optimized"

#define LMM_PREFIX         "lmm"

#define NMM_PREFIX         "nmm"

#define ASSEMBLE_OUTOPT    " -o " /* note - space before, space after */

#define ASSEMBLE_EEPROMOPT " -e" /* note - space before, but no space after */

#define ASSEMBLE_WARNOPT   " -w" /* note - space before, but no space after */

#define ASSEMBLE_INFOPT    " -i" /* note - space before, but no space after */

#define ASSEMBLE_OS        "spinnaker -p -a -D CATALINA_OPTIMIZE "
#define LISTOPT_OS         " -l"  /* note - space before, but no space after */
#define LIBOPT_OS          " -I " /* note - space before and after */
#define VERBOSE_OS         "-v "  /* note - space before and after */
#define QUIET_OS           "-q "

#define ASSEMBLE_P2        "p2_asm -l -D CATALINA_OPTIMIZE "
#define LISTOPT_P2         " -l"  /* note - space before, but no space after */
#define LIBOPT_P2          " -I " /* note - space before and after */
#define VERBOSE_P2         "" 
#define QUIET_P2           ""

#define OPTIMIZE_FILENAME_P1  "Catalina.spin"
#define OPTIMIZE_FILENAME_P2  "catalina.s"

#define CMD_DEFINE_STRING  "-D " /* note - space after */

#define PHASE_0_COMMAND    "catopt_0 "
#define PHASE_1_COMMAND    "catopt_1 "
#define PHASE_2_COMMAND    "catopt_2 "
#define PHASE_3_COMMAND    "catopt_3 "
#define PHASE_4_COMMAND    "catopt_4 "
#define PHASE_5_COMMAND    "catopt_5 "
#define PHASE_6_COMMAND    "catopt_6 "
#define PHASE_7_COMMAND    "catopt_7 "
#define PHASE_8_COMMAND    "catopt_8 "
#define PHASE_9_COMMAND    "catopt_9 "
#define PHASE_10_COMMAND   "catopt_10 "
#define PHASE_11_COMMAND   "catopt_11 "
#define PHASE_12_COMMAND   "catopt_12 "
#define PHASE_13_COMMAND   "catopt_13 "

static char lcc_path[MAX_LINELEN + 1] = "";
static char target_path[MAX_LINELEN + 1] = "";

/* global flags */
static int prop_vers = 1;
static int quiet     = 0;
static int verbose   = 0;
static int warning   = 0;
static int listing   = 0;
static int suppress  = 0;
static int olevel    = 0;
static int ilevel    = 3;
static int cleanup   = 1; 
static int format    = 0; // 0 => binary, 1 => eeprom

static int input_count = 0;
static char * input_file[MAX_FILES];     /* should only need one */

static int define_count = 0;
static char * define_symbol[MAX_DEFINES];

static int undefine_count = 0;
static char * undefine_symbol[MAX_DEFINES];

static int memory = 0;

static int spinnaker = 1; /* use spinnaker by default */

static int p2asm     = 0;

static char *memory_size;

static char *output_file;

static char *library_path;

static char assemble_command[MAX_LINELEN + 1] = ASSEMBLE_OS;
static char assemble_verbose[MAX_LINELEN + 1] = VERBOSE_OS;
static char assemble_quiet[MAX_LINELEN + 1]   = QUIET_OS;
static char assemble_options[MAX_LINELEN + 1] = "";

void help(char *my_name) {
   fprintf(stderr, "Catalina Optimizer %s\n", VERSION); 
   fprintf(stderr, "\nusage: %s [options] file\n\n", my_name);
   fprintf(stderr, "options:  -? or -h  print this helpful message (and exit)\n");
   fprintf(stderr, "          -b        binary output (default)\n");
   fprintf(stderr, "          -d        generate listing\n");
   fprintf(stderr, "          -D        define symbol\n");
   fprintf(stderr, "          -e        eeprom output\n");
   fprintf(stderr, "          -ilevel   set information level (note no space!)\n");
   fprintf(stderr, "          -I path   path to libraries\n");

   fprintf(stderr, "          -k        suppress banner\n");
   fprintf(stderr, "          -l        generate listing\n");
   fprintf(stderr, "          -L path   path to libraries\n");
   fprintf(stderr, "          -M size   memory size to use (default is 64k)\n");
   fprintf(stderr, "          -o name   output optimized results to file 'name'\n");
   fprintf(stderr, "          -p vers   Propeller version (1 or 2)\n");
   fprintf(stderr, "          -Olevel   optimization level (1 to 5, note no space!)\n");
   fprintf(stderr, "          -q        quiet output\n");
   fprintf(stderr, "          -T path   path to target to use\n");
   fprintf(stderr, "          -U symbol do not #define 'symbol' before assembling \n");
   fprintf(stderr, "          -u        do not remove intermediate output files\n");
   fprintf(stderr, "          -v        verbose (output information messages)\n");
   fprintf(stderr, "          -v -v     very verbose (more information messages)\n");
   fprintf(stderr, "          -w        enable warnings\n");
   fprintf(stderr, " exit code is non-zero on error)\n");
}

// safecpy will never write more than size characters, 
// and is guaranteed to null terminate its result, so
// make sure the buffer passed is at least size + 1
char * safecpy(char *dst, const char *src, size_t size) {
   dst[size] = '\0';
   if (src) {
      return strncpy(dst, src, size - strlen(dst));
   }
}

// safecat will never write more than size characters, 
// and is guaranteed to null terminate its resul, so
// make sure the buffer passed is at least size + 1
char * safecat(char *dst, const char *src, size_t size) {
   dst[size] = '\0';
   if (src) {
      return strncat(dst, src, size - strlen(dst));
   }
}

// pathcat will check for paths with spaces and quote
// them if we are using Win32 style path names, otherwise
// it is much the same as two safecats
void pathcat(char *dst, const char *src, const char *sfx, size_t max) {
#ifdef WIN32_PATHS
   if ((strchr(src, ' ') != NULL) && (src[0] != '\"')) {
      safecat(dst, "\"", max);
      safecat(dst, src, max);
      if (sfx != NULL) {
         safecat(dst, sfx, max);
      }
      safecat(dst, "\"", max);
   }
   else {
      safecat(dst, src, max);
      if (sfx != NULL) {
         safecat(dst, sfx, max);
      }
   }
#else
   safecat(dst, src, max);
   if (sfx != NULL) {
      safecat(dst, sfx, max);
   }
#endif   
}


/*
 * decode arguments, building file and library list - return -1 if
 * there is no further processing to do
 */
int decode_arguments (int argc, char *argv[]) {
   char   libname[MAX_LINELEN + 3 + 1];
   char * symbol;
   int    code = 0;
   int    i = 0;
   int    memsize;
   char   modifier;
   char   memstr[20];
   char   optnum[20];

   if (argc == 1) {
      if (strlen(argv[0]) == 0) {
         // in case my name was not passed in ...
         help("catoptimize");
      }
      else {
         help(argv[0]);
      }
      code = -1;
   }
   while ((code >= 0) && (argc--)) {
      if (verbose) {
        fprintf(stderr, "arg: %s\n", argv[i]);
      }
      if (i > 0) {
         if (argv[i][0] == '-') {
            if (verbose) {
              fprintf(stderr, "switch: %s\n", argv[i]);
            }
            // it's a command line switch
            switch (argv[i][1]) {
               case 'h':
               case '?':
                  if (strlen(argv[0]) == 0) {
                     // in case my name was not passed in ...
                     help("catoptimize");
                  }
                  else {
                     help(argv[0]);
                  }
                  break;
               case 'b':
                  format = 0;
                  if (verbose) {
                     fprintf(stderr, "binary\n");
                  }
                  break;
               case 'D':
                  if (strlen(argv[i]) == 2) {
                     // use next arg
                     if (argc > 0) {
                        symbol = strdup(argv[++i]);
                     }
                     else {
                        fprintf(stderr, "option -D requires an argument\n");
                        code = -1;
                        break;
                     }
                     argc--;
                  }
                  else {
                     // use remainder of this arg
                     symbol = strdup(&argv[i][2]);
                  }
                  if (define_count < MAX_DEFINES) {
                     define_symbol[define_count++] = symbol;
                     if (verbose) {
                        fprintf(stderr, "defining %s\n", symbol);
                     }
                  }
                  else {
                     fprintf(stderr, "too many defines - option -D ignored\n");
                  }
                  break;
               case 'd':
               case 'l':
                  listing = 1;
                  if (verbose) {
                     fprintf(stderr, "listing\n");
                  }
                  break;
               case 'k':
                  suppress = 1;
                  if (verbose) {
                     fprintf(stderr, "suppress\n");
                  }
                  break;
               case 'e':
                  format = 1;
                  if (verbose) {
                     fprintf(stderr, "eeprom\n");
                  }
                  break;
               case 'i':
                  if (strlen(argv[i]) == 2) {
                     ilevel = 1;
                  }
                  else {
                     // use remainder of this arg
                     sscanf(&argv[i][2], "%d", &ilevel);
                     if ((ilevel < 0) || (ilevel > 3)) {
                        fprintf(stderr, "information level %d not supported\n", ilevel);
                        code = -1;
                     }
                  }
                  if (verbose) {
                     fprintf(stderr, "information level %d\n", ilevel);
                  }
                  break;
               case 'o':
                  if (strlen(argv[i]) == 2) {
                     // use next arg
                     if (argc > 0) {
                        output_file = strdup(argv[++i]);
                     }
                     else {
                       fprintf(stderr, "option -o requires an argument\n");
                        code = -1;
                        break;
                     }
                     argc--;
                  }
                  else {
                     // use remainder of this arg
                     output_file = strdup(&argv[i][2]);
                  }
                  if (verbose) {
                    fprintf(stderr, "output file = %s\n", output_file);
                  }
                  break;
               case 'O':
                  if (strlen(argv[i]) == 2) {
                     olevel = 1;
                  }
                  else {
                     // use remainder of this arg
                     sscanf(&argv[i][2], "%d", &olevel);
                  }
                  if (verbose) {
                    fprintf(stderr, "optimize level %d\n", olevel);
                  }
                  break;
               case 'p':
                  if (strlen(argv[i]) == 2) {
                     // use next arg
                     if (argc > 0) {
                        sscanf(argv[++i], "%d", &prop_vers);
                        argc--;
                     }
                     else {
                        fprintf(stderr, "option -p requires an argument\n");
                        code = -1;
                        break;
                     }
                  }
                  else {
                     // use remainder of this arg
                     sscanf(&argv[i][2], "%d", &prop_vers);
                  }
                  if (verbose) {
                     fprintf(stderr, "propeller hardware version = %d\n", prop_vers);
                  }
                  if ((prop_vers < 1) || (prop_vers > 2)) {
                     fprintf(stderr, "Unknown propeller hardware version = %d\n", prop_vers);
                     code = -1;
                  }
                  if (prop_vers == 1) {
                     p2asm = 0;
                     spinnaker = 1;
                  }
                  if (prop_vers == 2) {
                     p2asm = 1;
                     spinnaker = 0;
                  }
                  break;

               case 'I':
                  if (strlen(argv[i]) == 2) {
                     // use next arg
                     if (argc > 0) {
                        library_path = strdup(argv[++i]);
                     }
                     else {
                       fprintf(stderr, "option -I requires an argument\n");
                        code = -1;
                        break;
                     }
                     argc--;
                  }
                  else {
                     // use remainder of this arg
                     library_path = strdup(&argv[i][2]);
                  }
                  if (verbose) {
                    fprintf(stderr, "library path = %s\n", library_path);
                  }
                  break;
               case 'L':
                  if (strlen(argv[i]) == 2) {
                     // use next arg
                     if (argc > 0) {
                        library_path = strdup(argv[++i]);
                     }
                     else {
                        fprintf(stderr, "option -L requires an argument\n");
                        code = -1;
                        break;
                     }
                     argc--;
                  }
                  else {
                     // use remainder of this arg
                     library_path = strdup(&argv[i][2]);
                  }
                  if (verbose) {
                    fprintf(stderr, "library path = %s\n", library_path);
                  }
                  break;
               case 'M':
                  memory = 1;
                  if (strlen(argv[i]) == 2) {
                     // use next arg
                     if (argc > 0) {
                        sscanf(argv[++i], "%d%c", &memsize, &modifier);
                     }
                     else {
                       fprintf(stderr, "option -M requires an argument\n");
                        code = -1;
                        break;
                     }
                     argc--;
                  }
                  else {
                     // use remainder of this arg
                     sscanf(&argv[i][2], "%d%c", &memsize, &modifier);
                  }
                  if (tolower(modifier) == 'k') {
                     memsize *= 1024;
                  }
                  else if (tolower(modifier) == 'm') {
                     memsize *= 1024 * 1024;
                  }
                  sprintf(memstr,"%d", memsize);
                  memory_size = strdup(memstr);
                  if (verbose) {
                    fprintf(stderr, "memory size = %s\n", memory_size);
                  }
                  break;
               case 'q':
                  quiet = 1;
                  break;
               case 'T':
                  if (strlen(argv[i]) == 2) {
                     // use next arg
                     if (argc > 0) {
                        strncpy(target_path, argv[++i], MAX_LINELEN);
                     }
                     else {
                        fprintf(stderr, "option -T requires an argument\n");
                        code = -1;
                        break;
                     }
                     argc--;
                  }
                  else {
                     // use remainder of this arg
                     strncpy(target_path, &argv[i][2], MAX_LINELEN);
                  }
                  if (verbose) {
                    fprintf(stderr, "target path = %s\n", target_path);
                  }
                  break;
               case 'U':
                  if (strlen(argv[i]) == 2) {
                     // use next arg
                     if (argc > 0) {
                        symbol = strdup(argv[++i]);
                     }
                     else {
                        fprintf(stderr, "option -U requires an argument\n");
                        code = -1;
                        break;
                     }
                     argc--;
                  }
                  else {
                     // use remainder of this arg
                     symbol = strdup(&argv[i][2]);
                  }
                  if (undefine_count < MAX_DEFINES) {
                     undefine_symbol[undefine_count++] = symbol;
                     if (verbose) {
                        fprintf(stderr, "undefining %s\n", symbol);
                     }
                  }
                  else {
                     fprintf(stderr, "too many undefines - option -U ignored\n");
                  }
                  break;
               case 'u':
                  cleanup = 0;
                  if (verbose) {
                     fprintf(stderr, "untidy (no cleanup) mode\n");
                  }
                  break;
               case 'v':
                  verbose++;
                  if (verbose == 1) {
                     fprintf(stderr, "verbose mode\n");
                  }
                  if (verbose > 1) {
                     fprintf(stderr, "very verbose mode\n");
                  }
                  break;
               case 'w':
                  warning = 1;
                  if (verbose) {
                     fprintf(stderr, "warning\n");
                  }
                  break;
               default:
                  fprintf(stderr, "unrecognized switch: %s\n", argv[i]);
                  code = -1; // force exit without further processing
                  break;
            }
         }
         else {
            // assume its a filename
            if (verbose) {
               printf("input filename = %s\n", argv[i]);
            }
            if (input_count < MAX_FILES) {
               input_file[input_count++] = strdup(argv[i]);
               code = 1; // work to do
            }
            else if (input_count > 1) {
               fprintf(stderr, "too many input files specified\n");
               code = -1; // force exit
            }
         }
      }
      i++; // next argument
   }
   if (verbose) {
      fprintf(stderr, "executable name = %s\n", argv[0]);
   }
   if (input_count == 0) {
      fprintf(stderr, "no input files specified\n");
      code = -1; // force exit
   }
   return code;

}

void unquote(char *name, char *unquoted) {
   int  len, i, j;
   
   len = strlen(name);
   if (len > MAX_PATHLEN) {
      len = MAX_PATHLEN;
   }
   j = 0;
   for (i = 0; i < len; i++) {
      if (name[i] != '\"') {
         unquoted[j++] = name[i];
      }
   }
   unquoted[j] = '\0';
}

int rename_unquoted(char *old, char *new) {
   char unquoted_old[MAX_PATHLEN + 1];
   char unquoted_new[MAX_PATHLEN + 1];

   unquote(old, unquoted_old);
   unquote(new, unquoted_new);
   if (verbose) {
      fprintf(stderr, "rename %s to %s\n", unquoted_old, unquoted_new);
   }
#if DO_EXECUTE   
   return rename(unquoted_old, unquoted_new);
#else
   return 0;
#endif   
}

int remove_unquoted(char *filename) {
   char unquoted_filename[MAX_PATHLEN + 1];

   unquote(filename, unquoted_filename);
   if (verbose) {
      fprintf(stderr, "remove %s\n", unquoted_filename);
   }
#if DO_EXECUTE   
   return remove(unquoted_filename);
#else
   return 0;
#endif   
}
   
void command_defines(char *to_string, int size) {
   int i, j;
   int defined = 0;

   for (i = 0; i < define_count; i++) {
      defined = 1;
      // check symbol has not been undefined
      for (j = 0; j < undefine_count; j++) {
         if (strcmp(define_symbol[i], undefine_symbol[j]) == 0) {
            defined = 0;
         }
      }
      if (defined) {
         safecat(to_string, CMD_DEFINE_STRING, size);
         if ((strchr(define_symbol[i], '=') != NULL) || (strchr(define_symbol[i], ' ') != NULL)) {
            // complex symbol definition - must quote it (only works on P2)
            safecat(to_string, "\"", size);
            safecat(to_string, define_symbol[i], size);
            safecat(to_string, "\"", size);
         }
         else {
            // simple symbol definition (works on P1 or P2)
            safecat(to_string, define_symbol[i], size);
         }
         safecat(to_string, " ", size);
      }
   }
}

int do_assemble(char *fullname, char *outname, int listing, char *library) {
   char     assemble[MAX_LINELEN + 1] = "";
   int      result = 0;
   char     number_string[MAX_LINELEN + 1] = "";

   if (verbose) {
     fprintf(stderr, "assembling %s\n", fullname);
   }
   safecpy(assemble, assemble_command, MAX_LINELEN);
   if (verbose == 0) {
      safecat(assemble, assemble_quiet, MAX_LINELEN);
   }
   if (verbose > 1) {
      safecat(assemble, assemble_verbose, MAX_LINELEN);
   }
   // define symbols on command line
   command_defines(assemble, MAX_LINELEN);
   safecat(assemble, "\"", MAX_LINELEN);
   safecat(assemble, fullname, MAX_LINELEN);
   safecat(assemble, "\"", MAX_LINELEN);
   if (memory) {
      safecat(assemble, " -M ", MAX_LINELEN);
      safecat(assemble, memory_size, MAX_LINELEN);
   }
   if (outname) {
      safecat(assemble, ASSEMBLE_OUTOPT, MAX_LINELEN);
      safecat(assemble, "\"", MAX_LINELEN);
      safecat(assemble, outname, MAX_LINELEN);
      safecat(assemble, "\"", MAX_LINELEN);
   }
   safecat(assemble, " ", MAX_LINELEN);
   safecat(assemble, assemble_options, MAX_LINELEN);
   if (listing) {
      if (spinnaker) {
         safecat(assemble, LISTOPT_OS, MAX_LINELEN);
      }
      else if (p2asm) {
         safecat(assemble, LISTOPT_P2, MAX_LINELEN);
      }
   }
   if (format) {
      safecat(assemble, ASSEMBLE_EEPROMOPT, MAX_LINELEN);
   }
   if (warning) {
      safecat(assemble, ASSEMBLE_WARNOPT, MAX_LINELEN);
   }
   if (ilevel < 3) {
      sprintf(number_string, "%s%0d", ASSEMBLE_INFOPT, ilevel);
      safecat(assemble, number_string, MAX_LINELEN);
   }
   if (library != NULL) {
      if (prop_vers == 2) {
         safecat(assemble, LIBOPT_P2, MAX_LINELEN);
      }
      else if (spinnaker) {
         safecat(assemble, LIBOPT_OS, MAX_LINELEN);
      }
      safecat(assemble, "\"", MAX_LINELEN);
      safecat(assemble, library, MAX_LINELEN);
      safecat(assemble, "\"", MAX_LINELEN);
   }
   else {
      if (library_path != NULL) {
         if (prop_vers == 2) {
            safecat(assemble, LIBOPT_P2, MAX_LINELEN);
         }
         else if (spinnaker) {
            safecat(assemble, LIBOPT_OS, MAX_LINELEN);
         }
         safecat(assemble, "\"", MAX_LINELEN);
         safecat(assemble, library_path, MAX_LINELEN);
         safecat(assemble, "\"", MAX_LINELEN);
      }
   }
   if (prop_vers == 2) {
     safecat(assemble, LIBOPT_P2, MAX_LINELEN);
   }
   else if (spinnaker) {
      safecat(assemble, LIBOPT_OS, MAX_LINELEN);
   }
   safecat(assemble, ".", MAX_LINELEN);
   if (verbose) {
      fprintf(stderr, "assemble command = %s\n", assemble);
   }
#if DO_EXECUTE
   if ((result = system(assemble)) != 0) {
      if (verbose) {
        fprintf(stderr, "assemble result = %d\n", result);
      }
   }
#endif
   return result;
}

int do_phase_0(char *fullname) {
   char optimize[MAX_LINELEN + 1] = "";
   int result = 0;

   if (verbose) {
     fprintf(stderr, "phase 0\n");
   }
   safecpy(optimize, PHASE_0_COMMAND, MAX_LINELEN);
   safecat(optimize, "\"", MAX_LINELEN);
   safecat(optimize, fullname, MAX_LINELEN);
   safecat(optimize, "\"", MAX_LINELEN);
   safecat(optimize, " >", MAX_LINELEN);
   safecat(optimize, OPTIMIZER_PHASE_0_OUTPUT_NAME, MAX_LINELEN);
   if (verbose) {
      printf("command = %s\n", optimize);
   }
#if DO_EXECUTE
   if ((result = system(optimize)) != 0) {
      if (verbose) {
         fprintf(stderr, "result = %d\n", result);
      }
   }
#endif   
   return result;   
}

int dummy_phase_0(char *fullname) {
   char optimize[MAX_LINELEN + 1] = "";
   int result = 0;

   remove_unquoted(OPTIMIZER_PHASE_0_OUTPUT_NAME);
   if (verbose) {
     fprintf(stderr, "phase 0 %s\n", fullname);
   }
#if DO_EXECUTE
   if (result = rename_unquoted(fullname, OPTIMIZER_PHASE_0_OUTPUT_NAME) != 0) {
      if (verbose) {
         fprintf(stderr, "result = %d\n", result);
      }
   }
#endif   
   return result;   
}

int do_phase_1(char *fullname) {
   char optimize[MAX_LINELEN + 1] = "";
   int result = 0;

   if (verbose) {
     fprintf(stderr, "phase 1 %s\n", fullname);
   }
   safecpy(optimize, PHASE_1_COMMAND, MAX_LINELEN);
   safecat(optimize, "\"", MAX_LINELEN);
   safecat(optimize, fullname, MAX_LINELEN);
   safecat(optimize, "\"", MAX_LINELEN);
   safecat(optimize, " >", MAX_LINELEN);
   safecat(optimize, OPTIMIZER_PHASE_1_OUTPUT_NAME, MAX_LINELEN);
   if (verbose) {
      printf("command = %s\n", optimize);
   }
#if DO_EXECUTE
   if ((result = system(optimize)) != 0) {
      if (verbose) {
         fprintf(stderr, "result = %d\n", result);
      }
   }
#endif
   return result;   
}

int do_phase_2(char *fullname) {
   char optimize[MAX_LINELEN + 1] = "";
   int result = 0;

   if (verbose) {
     fprintf(stderr, "phase 2 %s\n", fullname);
   }
   safecpy(optimize, PHASE_2_COMMAND, MAX_LINELEN);
   safecat(optimize, "\"", MAX_LINELEN);
   safecat(optimize, fullname, MAX_LINELEN);
   safecat(optimize, "\"", MAX_LINELEN);
   if (verbose) {
      printf("command = %s\n", optimize);
   }
#if DO_EXECUTE
   if ((result = system(optimize)) != 0) {
      if (verbose) {
         fprintf(stderr, "result = %d\n", result);
      }
   }
#endif   
   return result;   
}

int do_phase_3(char *fullname) {
   char optimize[MAX_LINELEN + 1] = "";
   int result = 0;

   if (verbose) {
     fprintf(stderr, "phase 3 %s\n", fullname);
   }
   safecpy(optimize, PHASE_3_COMMAND, MAX_LINELEN);
   safecat(optimize, "\"", MAX_LINELEN);
   safecat(optimize, fullname, MAX_LINELEN);
   safecat(optimize, "\"", MAX_LINELEN);
   safecat(optimize, " >", MAX_LINELEN);
   safecat(optimize, OPTIMIZER_PHASE_3_OUTPUT_TEMP, MAX_LINELEN);
   if (verbose) {
      printf("command = %s\n", optimize);
   }
#if DO_EXECUTE
   if ((result = system(optimize)) != 0) {
      if (verbose) {
         fprintf(stderr, "result = %d\n", result);
      }
   }
#endif
   // We must run phase 3 twice - to make sure all calls are 
   // processed correctly, even if they are on consecutive lines
   if (result == 0) {
      safecpy(optimize, PHASE_3_COMMAND, MAX_LINELEN);
      safecat(optimize, "\"", MAX_LINELEN);
      safecat(optimize, OPTIMIZER_PHASE_3_OUTPUT_TEMP, MAX_LINELEN);
      safecat(optimize, "\"", MAX_LINELEN);
      safecat(optimize, " >", MAX_LINELEN);
      safecat(optimize, OPTIMIZER_PHASE_3_OUTPUT_NAME, MAX_LINELEN);
      if (verbose) {
         printf("command = %s\n", optimize);
      }
#if DO_EXECUTE
      if ((result = system(optimize)) != 0) {
         if (verbose) {
            fprintf(stderr, "result = %d\n", result);
         }
      }
   }
#endif   
   return result;   
}


int dummy_phase_1_to_3(char *fullname) {
   char optimize[MAX_LINELEN + 1] = "";
   int result = 0;

   remove_unquoted(OPTIMIZER_PHASE_3_OUTPUT_TEMP);
   remove_unquoted(OPTIMIZER_PHASE_3_OUTPUT_NAME);
   if (verbose) {
     fprintf(stderr, "phase 1-3 %s\n", fullname);
   }
#if DO_EXECUTE
   if (result = rename_unquoted(fullname, OPTIMIZER_PHASE_3_OUTPUT_NAME) != 0) {
      if (verbose) {
         fprintf(stderr, "result = %d\n", result);
      }
   }
#endif   
   return result;   
}

int do_phase_4(char *fullname) {
   char optimize[MAX_LINELEN + 1] = "";
   int result = 0;

   if (verbose) {
     fprintf(stderr, "phase 4\n");
   }
   safecpy(optimize, PHASE_4_COMMAND, MAX_LINELEN);
   safecat(optimize, "\"", MAX_LINELEN);
   safecat(optimize, fullname, MAX_LINELEN);
   safecat(optimize, "\"", MAX_LINELEN);
   safecat(optimize, " >", MAX_LINELEN);
   safecat(optimize, OPTIMIZER_PHASE_4_OUTPUT_NAME, MAX_LINELEN);
   if (verbose) {
      printf("command = %s\n", optimize);
   }
#if DO_EXECUTE
   if ((result = system(optimize)) != 0) {
      if (verbose) {
         fprintf(stderr, "result = %d\n", result);
      }
      return result;
   }
#endif   
   return result;   
}

int do_phase_5(char *fullname) {
   char optimize[MAX_LINELEN + 1] = "";
   int result = 0;

   if (verbose) {
     fprintf(stderr, "phase 5\n");
   }
   safecpy(optimize, PHASE_5_COMMAND, MAX_LINELEN);
   safecat(optimize, "\"", MAX_LINELEN);
   safecat(optimize, fullname, MAX_LINELEN);
   safecat(optimize, "\"", MAX_LINELEN);
   safecat(optimize, " >", MAX_LINELEN);
   safecat(optimize, OPTIMIZER_PHASE_5_OUTPUT_NAME, MAX_LINELEN);
   if (verbose) {
      printf("command = %s\n", optimize);
   }
#if DO_EXECUTE
   if ((result = system(optimize)) != 0) {
      if (verbose) {
         fprintf(stderr, "result = %d\n", result);
      }
   }
#endif   
   return result;   
}

int do_phase_6(char *fullname) {
   char optimize[MAX_LINELEN + 1] = "";
   int result = 0;

   if (verbose) {
     fprintf(stderr, "phase 6\n");
   }
   safecpy(optimize, PHASE_6_COMMAND, MAX_LINELEN);
   safecat(optimize, "\"", MAX_LINELEN);
   safecat(optimize, fullname, MAX_LINELEN);
   safecat(optimize, "\"", MAX_LINELEN);
   safecat(optimize, " >", MAX_LINELEN);
   safecat(optimize, OPTIMIZER_PHASE_6_OUTPUT_NAME, MAX_LINELEN);
   if (verbose) {
      printf("command = %s\n", optimize);
   }
#if DO_EXECUTE
   if ((result = system(optimize)) != 0) {
      if (verbose) {
         fprintf(stderr, "result = %d\n", result);
      }
   }
#endif   
   return result;   
}

int do_phase_7(char *fullname) {
   char optimize[MAX_LINELEN + 1] = "";
   int result = 0;

   if (verbose) {
     fprintf(stderr, "phase 7\n");
   }
   safecpy(optimize, PHASE_7_COMMAND, MAX_LINELEN);
   safecat(optimize, "\"", MAX_LINELEN);
   safecat(optimize, fullname, MAX_LINELEN);
   safecat(optimize, "\"", MAX_LINELEN);
   safecat(optimize, " >", MAX_LINELEN);
   safecat(optimize, OPTIMIZER_PHASE_7_OUTPUT_NAME, MAX_LINELEN);
   if (verbose) {
      printf("command = %s\n", optimize);
   }
#if DO_EXECUTE
   if ((result = system(optimize)) != 0) {
      if (verbose) {
         fprintf(stderr, "result = %d\n", result);
      }
   }
#endif   
   return result;   
}

int do_phase_8(char *fullname) {
   char optimize[MAX_LINELEN + 1] = "";
   int result = 0;

   if (verbose) {
     fprintf(stderr, "phase 8\n");
   }
   safecpy(optimize, PHASE_8_COMMAND, MAX_LINELEN);
   safecat(optimize, "\"", MAX_LINELEN);
   safecat(optimize, fullname, MAX_LINELEN);
   safecat(optimize, "\"", MAX_LINELEN);
   if (verbose) {
      printf("command = %s\n", optimize);
   }
#if DO_EXECUTE
   if ((result = system(optimize)) != 0) {
      if (verbose) {
         fprintf(stderr, "result = %d\n", result);
      }
   }
#endif   
   return result;   
}

int do_phase_9(char *fullname) {
   char optimize[MAX_LINELEN + 1] = "";
   int result = 0;

   if (verbose) {
     fprintf(stderr, "phase 9\n");
   }
   safecpy(optimize, PHASE_9_COMMAND, MAX_LINELEN);
   safecat(optimize, "\"", MAX_LINELEN);
   safecat(optimize, fullname, MAX_LINELEN);
   safecat(optimize, "\"", MAX_LINELEN);
   safecat(optimize, " >", MAX_LINELEN);
   safecat(optimize, OPTIMIZER_PHASE_9_OUTPUT_NAME, MAX_LINELEN);
   if (verbose) {
      printf("command = %s\n", optimize);
   }
#if DO_EXECUTE
   if ((result = system(optimize)) != 0) {
      if (verbose) {
        fprintf(stderr, "result = %d\n", result);
      }
   }
#endif   
   return result;   
}

int do_phase_10(char *fullname) {
   char optimize[MAX_LINELEN + 1] = "";
   int result = 0;

   if (verbose) {
     fprintf(stderr, "phase 10\n");
   }
   safecpy(optimize, PHASE_10_COMMAND, MAX_LINELEN);
   safecat(optimize, "\"", MAX_LINELEN);
   safecat(optimize, fullname, MAX_LINELEN);
   safecat(optimize, "\"", MAX_LINELEN);
   safecat(optimize, " >", MAX_LINELEN);
   safecat(optimize, OPTIMIZER_PHASE_10_OUTPUT_NAME, MAX_LINELEN);
   if (verbose) {
      printf("command = %s\n", optimize);
   }
#if DO_EXECUTE
   if ((result = system(optimize)) != 0) {
      if (verbose) {
        fprintf(stderr, "result = %d\n", result);
      }
   }
#endif   
   return result;   
}

int do_phase_11(char *fullname) {
   char optimize[MAX_LINELEN + 1] = "";
   int result = 0;

   if (verbose) {
     fprintf(stderr, "phase 11\n");
   }
   safecpy(optimize, PHASE_11_COMMAND, MAX_LINELEN);
   safecat(optimize, "\"", MAX_LINELEN);
   safecat(optimize, fullname, MAX_LINELEN);
   safecat(optimize, "\"", MAX_LINELEN);
   safecat(optimize, " >", MAX_LINELEN);
   safecat(optimize, OPTIMIZER_PHASE_11_OUTPUT_NAME, MAX_LINELEN);
   if (verbose) {
      printf("command = %s\n", optimize);
   }
#if DO_EXECUTE
   if ((result = system(optimize)) != 0) {
      if (verbose) {
         fprintf(stderr, "result = %d\n", result);
      }
   }
#endif   
   return result;   
}

int do_phase_12(char *fullname) {
   char optimize[MAX_LINELEN + 1] = "";
   int result = 0;

   if (verbose) {
     fprintf(stderr, "phase 12\n");
   }
   safecpy(optimize, PHASE_12_COMMAND, MAX_LINELEN);
   safecat(optimize, "\"", MAX_LINELEN);
   safecat(optimize, fullname, MAX_LINELEN);
   safecat(optimize, "\"", MAX_LINELEN);
   if (verbose) {
      printf("command = %s\n", optimize);
   }
#if DO_EXECUTE
   if ((result = system(optimize)) != 0) {
      if (verbose) {
         fprintf(stderr, "result = %d\n", result);
      }
   }
#endif   
   return result;   
}

int do_phase_13(char *fullname) {
   char optimize[MAX_LINELEN + 1] = "";
   int result = 0;

   if (verbose) {
     fprintf(stderr, "phase 13\n");
   }
   safecpy(optimize, PHASE_13_COMMAND, MAX_LINELEN);
   safecat(optimize, "\"", MAX_LINELEN);
   safecat(optimize, fullname, MAX_LINELEN);
   safecat(optimize, "\"", MAX_LINELEN);
   safecat(optimize, " >", MAX_LINELEN);
   safecat(optimize, OPTIMIZER_PHASE_13_OUTPUT_NAME, MAX_LINELEN);
   if (verbose) {
      printf("command = %s\n", optimize);
   }
#if DO_EXECUTE
   if ((result = system(optimize)) != 0) {
      if (verbose) {
         fprintf(stderr, "result = %d\n", result);
      }
   }
#endif   
   return result;   
}

int do_optimize(char *fullname) {
   int   code;

   if (verbose) {
     fprintf(stderr, "optimizing, file name = %s\n", fullname);
   }

   if (olevel >= 5) {
      code = do_phase_0(fullname);
      if (code != 0) {
         return code;
      }
   }
   else {
      code = dummy_phase_0(fullname);
      if (code != 0) {
         return code;
      }
   }
   if (olevel >= 3) {
      code = do_phase_1(OPTIMIZER_PHASE_0_OUTPUT_NAME);
      if (code != 0) {
         return code;
      }
      code = do_phase_2(OPTIMIZER_PHASE_0_OUTPUT_NAME);
      if (code != 0) {
         return code;
      }
      code = do_phase_3(OPTIMIZER_PHASE_0_OUTPUT_NAME);
      if (code != 0) {
         return code;
      }
   }
   else {
      code = dummy_phase_1_to_3(OPTIMIZER_PHASE_0_OUTPUT_NAME);
      if (code != 0) {
         return code;
      }
   }
   code = do_phase_4(OPTIMIZER_PHASE_3_OUTPUT_NAME);
   if (code != 0) {
      return code;
   }
   code = do_assemble(OPTIMIZER_PHASE_4_OUTPUT_NAME, NULL, 1, target_path); 
   if (code != 0) {
      return code;
   }
   code = do_phase_5(OPTIMIZER_PHASE_4_LISTING_NAME);
   if (code != 0) {
      return code;
   }
   code = do_phase_6(OPTIMIZER_PHASE_4_OUTPUT_NAME);
   if (code != 0) {
      return code;
   }
   code = do_phase_7(OPTIMIZER_PHASE_6_OUTPUT_NAME);
   if (code != 0) {
      return code;
   }
   code = do_phase_8(OPTIMIZER_PHASE_6_OUTPUT_NAME);
   if (code != 0) {
      return code;
   }
   code = do_phase_9(OPTIMIZER_PHASE_6_OUTPUT_NAME);
   if (code != 0) {
      return code;
   }
   code = do_phase_10(OPTIMIZER_PHASE_9_OUTPUT_NAME);
   if (code != 0) {
      return code;
   }
   remove_unquoted(fullname);
   code = rename_unquoted(OPTIMIZER_PHASE_10_OUTPUT_NAME, fullname);
   if (code != 0) {
      return code;
   }
   code = do_assemble(input_file[0], output_file, listing, target_path); 
   if (code != 0) {
      return code;
   }
   if (olevel > 1) {
      code = dummy_phase_1_to_3(fullname);
      if (code != 0) {
         return code;
      }
      code = do_phase_4(OPTIMIZER_PHASE_3_OUTPUT_NAME);
      if (code != 0) {
         return code;
      }
      code = do_assemble(OPTIMIZER_PHASE_4_OUTPUT_NAME, NULL, 1, target_path); 
      if (code != 0) {
         return code;
      }
      code = do_phase_5(OPTIMIZER_PHASE_4_LISTING_NAME);
      if (code != 0) {
         return code;
      }
      code = do_phase_6(OPTIMIZER_PHASE_4_OUTPUT_NAME);
      if (code != 0) {
         return code;
      }
      remove_unquoted(fullname);
      if (olevel >= 4) {
         code = do_phase_11(OPTIMIZER_PHASE_6_OUTPUT_NAME);
         if (code != 0) {
            return code;
         }
         code = do_phase_12(OPTIMIZER_PHASE_6_OUTPUT_NAME);
         if (code != 0) {
            return code;
         }
         code = do_phase_13(OPTIMIZER_PHASE_6_OUTPUT_NAME);
         if (code != 0) {
            return code;
         }
         code = rename_unquoted(OPTIMIZER_PHASE_13_OUTPUT_NAME, fullname);
      }
      else {
         code = rename_unquoted(OPTIMIZER_PHASE_6_OUTPUT_NAME, fullname);
      }
      code = do_assemble(input_file[0], output_file, listing, target_path); 
      if (code != 0) {
         return code;
      }
   }

   if (cleanup) {
      if (verbose) {
        fprintf(stderr, "cleaning up intermediate files\n");
      }
      // delete preprocessed files
      remove_unquoted(OPTIMIZER_PHASE_0_OUTPUT_NAME);
      remove_unquoted(OPTIMIZER_PHASE_1_OUTPUT_NAME);
      remove_unquoted(OPTIMIZER_PHASE_2_OUTPUT_NAME);
      remove_unquoted(OPTIMIZER_PHASE_3_OUTPUT_TEMP);
      remove_unquoted(OPTIMIZER_PHASE_3_OUTPUT_NAME);
      remove_unquoted(OPTIMIZER_PHASE_4_OUTPUT_NAME);
      remove_unquoted(OPTIMIZER_PHASE_4_BINARY_NAME);
      remove_unquoted(OPTIMIZER_PHASE_4_BINARY_NAME_P2);
      remove_unquoted(OPTIMIZER_PHASE_4_LISTING_NAME);
      remove_unquoted(OPTIMIZER_PHASE_5_OUTPUT_NAME);
      remove_unquoted(OPTIMIZER_PHASE_6_OUTPUT_NAME);
      remove_unquoted(OPTIMIZER_PHASE_7_OUTPUT_NAME);
      remove_unquoted(OPTIMIZER_PHASE_8_OUTPUT_NAME);
      remove_unquoted(OPTIMIZER_PHASE_9_OUTPUT_NAME);
      remove_unquoted(OPTIMIZER_PHASE_11_OUTPUT_NAME);
      remove_unquoted(OPTIMIZER_PHASE_12_OUTPUT_NAME);
   }
   return 0;
}

int main(int argc, char *argv[]) {
   char *name;
   char *sep = PATH_SEP;
   int code = 0;
   int optimize = 0;

   library_path = NULL;

   if (decode_arguments(argc, argv) <= 0) {
      if (verbose) {
        fprintf(stderr, "%s exiting\n", argv[0]);
      }
      exit(0);
   }

   safecpy(lcc_path, getenv(DEFAULT_LCC_ENV), MAX_LINELEN);

   // if no target specified on command line, get it from the
   // environment variable
   if (strlen(target_path) == 0) {
      safecpy(target_path, getenv(DEFAULT_TGT_ENV), MAX_LINELEN);
   }

   if (suppress == 0) {
      fprintf(stderr, "Catalina Optimizer %s\n", VERSION); 
   }

   if (strlen(target_path) == 0) {
      if (strlen(lcc_path) > 0) {
         safecpy(target_path, lcc_path, MAX_LINELEN);
         safecat(target_path, PATH_SEP, MAX_LINELEN);
      }
      else {
         safecpy(target_path, DEFAULT_LCCDIR, MAX_LINELEN);
      }
      safecat(target_path, TARGET_NAME, MAX_LINELEN);
   }

   if (prop_vers == 2) {
      safecat(target_path, PATH_SEP, MAX_LINELEN);
      safecat(target_path, P2_SUFFIX, MAX_LINELEN);
   }
   else {
      safecat(target_path, PATH_SEP, MAX_LINELEN);
      safecat(target_path, P1_SUFFIX, MAX_LINELEN);
   }

   if (spinnaker) {
       strcpy(assemble_command, ASSEMBLE_OS);
       strcpy(assemble_verbose, VERBOSE_OS);
       strcpy(assemble_quiet, QUIET_OS);
   }
   else if (p2asm) {
       strcpy(assemble_command, ASSEMBLE_P2);
       strcpy(assemble_verbose, VERBOSE_P2);
       strcpy(assemble_quiet, QUIET_P2);
   }

   if (library_path == NULL) {
      library_path = target_path;
   }
   
   if (output_file == NULL) {
      output_file = DEFAULT_RESULT;
      if (verbose) {
        fprintf(stderr, "output file = %s\n", output_file);
      }
   }

   if (prop_vers == 1) {
      // check if we are compiling a file that should be optimized,
      // or which includes a file that should be optimized
      // (a bit of a hack for the Propeller 1)
      name = strrchr(input_file[0], sep[0]);
      if (name != NULL) {
         name++;
      }
      else {
         name = input_file[0];
      }
      if (name != NULL) {
         if (verbose) {
            printf ("base file name =  %s\n", name); 
         }
         if (strcmp(name, OPTIMIZE_FILENAME_P1) == 0) {
            optimize = 1;
         }
         if (strncmp(name, LMM_PREFIX, 3) == 0) {
            optimize = 1;
         }
         if (strncmp(name, NMM_PREFIX, 3) == 0) {
            optimize = 1;
         }
      }

      if (optimize) {
         code = do_optimize(OPTIMIZE_FILENAME_P1);
      }
      else {
         code = do_assemble(input_file[0], output_file, listing, target_path); 
      }
   }
   else {
      code = do_optimize(input_file[0]);
   }

   if (verbose) {
     fprintf(stderr, "\n%s done, result = %d\n", argv[0], code);
   }
   exit(code);
}
